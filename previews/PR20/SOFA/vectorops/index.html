<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Vectorops · Astrometry.jl</title><meta name="title" content="Vectorops · Astrometry.jl"/><meta property="og:title" content="Vectorops · Astrometry.jl"/><meta property="twitter:title" content="Vectorops · Astrometry.jl"/><meta name="description" content="Documentation for Astrometry.jl."/><meta property="og:description" content="Documentation for Astrometry.jl."/><meta property="twitter:description" content="Documentation for Astrometry.jl."/><meta property="og:url" content="https://juliaastro.org/Astrometry/stable/SOFA/vectorops/"/><meta property="twitter:url" content="https://juliaastro.org/Astrometry/stable/SOFA/vectorops/"/><link rel="canonical" href="https://juliaastro.org/Astrometry/stable/SOFA/vectorops/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2"><span class="docs-label">The SOFA sub-package</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../astrometry/">Astrometry</a></li><li><a class="tocitem" href="../calendars/">Calendars</a></li><li><a class="tocitem" href="../coefficients/">Coefficients</a></li><li><a class="tocitem" href="../ecliptic/">Ecliptic</a></li><li><a class="tocitem" href="../ephemerides/">Ephemerides</a></li><li><a class="tocitem" href="../equatorial/">Equatorial</a></li><li><a class="tocitem" href="../galactic/">Galactic</a></li><li><a class="tocitem" href="../geocentric/">Geocentric</a></li><li><a class="tocitem" href="../gnomonic/">Gnomonic</a></li><li><a class="tocitem" href="../precession/">Precession</a></li><li><a class="tocitem" href="../rotations/">Rotations</a></li><li><a class="tocitem" href="../spacemotion/">Space Motion</a></li><li><a class="tocitem" href="../starcatalogs/">Star Catalogs</a></li><li><a class="tocitem" href="../timescales/">Timescales</a></li><li class="is-active"><a class="tocitem" href>Vectorops</a></li></ul></li><li><a class="tocitem" href="../../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">The SOFA sub-package</a></li><li class="is-active"><a href>Vectorops</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Vectorops</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaAstro/Astrometry.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaAstro/Astrometry.jl/blob/main/docs/src/SOFA/vectorops.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="vectorops.jl"><a class="docs-heading-anchor" href="#vectorops.jl">vectorops.jl</a><a id="vectorops.jl-1"></a><a class="docs-heading-anchor-permalink" href="#vectorops.jl" title="Permalink"></a></h1><p>Missing docs:</p><ul><li>SOFA.rv2m</li></ul><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.a2af"><a class="docstring-binding" href="#Astrometry.SOFA.a2af"><code>Astrometry.SOFA.a2af</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">a2af(ndp::Integer, angle::Real)</code></pre><p>Decompose radians into degrees, arcminutes, arcseconds, and fraction.</p><p><strong>Input</strong></p><ul><li><code>npd</code>   –number of useful digits</li><li><code>angle</code> – angle in radians</li></ul><p><strong>Output</strong></p><ul><li><code>dms</code>   – angle in sign, degrees, minutes, seconds, and fraction</li></ul><p><strong>Note</strong></p><ol><li><p>The argument ndp is interpreted as follows:</p><p>ndp         resolution  :      ...0000 00 00 -7         1000 00 00 -6          100 00 00 -5           10 00 00 -4            1 00 00 -3            0 10 00 -2            0 01 00 -1            0 00 10  0            0 00 01  1            0 00 00.1  2            0 00 00.01  3            0 00 00.001  :            0 00 00.000...</p></li><li><p>The largest positive useful value for ndp is determined by the size of angle, the format of Float64 on the target platform, and the risk of overflowing dms[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits.</p></li><li><p>The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where days is very nearly 2pi and rounds up to 2pi and rounds up to 360 degree, by testing for dms[0]=360 and setting dms[0-3] to zero.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L3-L47">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.a2tf"><a class="docstring-binding" href="#Astrometry.SOFA.a2tf"><code>Astrometry.SOFA.a2tf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">a2tf(ndp::Integer, angle::Real)</code></pre><p>Decompose radians into hours, minutes, seconds, and fraction.</p><p><strong>Input</strong></p><ul><li><code>npd</code>   – number of useful digits</li><li><code>angle</code> – angle in radians</li></ul><p><strong>Output</strong></p><ul><li><code>hms</code>   – angle in sign, hour, minutes, seconds, and fraction</li></ul><p><strong>Note</strong></p><ol><li><p>The argument ndp is interpreted as follows:</p><p>ndp         resolution  :      ...0000 00 00 -7         1000 00 00 -6          100 00 00 -5           10 00 00 -4            1 00 00 -3            0 10 00 -2            0 01 00 -1            0 00 10  0            0 00 01  1            0 00 00.1  2            0 00 00.01  3            0 00 00.001  :            0 00 00.000...</p></li><li><p>The largest positive useful value for ndp is determined by the size of angle, the format of Float64 on the target platform, and the risk of overflowing hms[3].  On a typical platform, for angle up to 2pi, the available floating-point precision might correspond to ndp=12.  However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits.</p></li><li><p>The absolute value of angle may exceed 2pi.  In cases where it does not, it is up to the caller to test for and handle the case where days is very nearly 2pi and rounds up to 2pi and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L53-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.af2a"><a class="docstring-binding" href="#Astrometry.SOFA.af2a"><code>Astrometry.SOFA.af2a</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">af2a(sign::Char, degree::Integer, minute::Integer, second::Real)</code></pre><p>Convert degrees, arcminutes, arcseconds to radians.</p><p><strong>Input</strong></p><ul><li><code>sign</code>   – sign of arc</li><li><code>degree</code> – degrees of arc</li><li><code>minute</code> – minutes of arc</li><li><code>second</code> – seconds of arc</li></ul><p><strong>Output</strong></p><ul><li><code>angle</code>  – angle in radians</li></ul><p><strong>Note</strong></p><ol><li><p>The result is computed even if any of the range checks fail.</p></li><li><p>Negative ideg, iamin and/or asec produce a warning status, but the absolute value is used in the conversion.</p></li><li><p>If there are multiple errors, the status value reflects only the first, the smallest taking precedence.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L101-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.anp"><a class="docstring-binding" href="#Astrometry.SOFA.anp"><code>Astrometry.SOFA.anp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">anp(angle::Real)</code></pre><p>Normalize angle into the range 0 &lt;= a &lt; 2p.</p><p><strong>Input</strong></p><ul><li><code>angle</code> – angle in radians</li></ul><p><strong>Output</strong></p><ul><li><code>angle</code> – angle in radians in range 0-2pi</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L137-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.anpm"><a class="docstring-binding" href="#Astrometry.SOFA.anpm"><code>Astrometry.SOFA.anpm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">anpm(angle::Real)</code></pre><p>Normalize angle into the range -pi &lt;= a &lt; +pi</p><p><strong>Input</strong></p><ul><li><code>angle</code> – angle in radians</li></ul><p><strong>Output</strong></p><ul><li><code>angle</code> – angle in radians in range +/-pi</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L154-L166">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.d2tf"><a class="docstring-binding" href="#Astrometry.SOFA.d2tf"><code>Astrometry.SOFA.d2tf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">d2tf(ndp::Integer, day::Real)</code></pre><p>Decompose days to sign, hours, minutes, seconds, fraction.</p><p><strong>Input</strong></p><ul><li><code>npd</code>   – number of usefule digits</li><li><code>day</code>   – interval in days</li></ul><p><strong>Output</strong></p><ul><li><code>hms</code>   – hms in sign, hours, minutes, seconds, and fraction</li></ul><p><strong>Note</strong></p><ol><li><p>The argument ndp is interpreted as follows:</p><p>ndp         resolution  :      ...0000 00 00 -7         1000 00 00 -6          100 00 00 -5           10 00 00 -4            1 00 00 -3            0 10 00 -2            0 01 00 -1            0 00 10  0            0 00 01  1            0 00 00.1  2            0 00 00.01  3            0 00 00.001  :            0 00 00.000...</p></li><li><p>The largest positive useful value for ndp is determined by the size of days, the format of Float64 on the target platform, and the risk of overflowing hms[3].  On a typical platform, for days up to 1.0, the available floating-point precision might correspond to ndp=12. However, the practical limit is typically ndp=9, set by the capacity of a 32-bit int, or ndp=4 if int is only 16 bits.</p></li><li><p>The absolute value of days may exceed 1.0.  In cases where it does not, it is up to the caller to test for and handle the case where days is very nearly 1.0 and rounds up to 24 hours, by testing for ihmsf[0]=24 and setting ihmsf[0-3] to zero.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L171-L215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.tf2a"><a class="docstring-binding" href="#Astrometry.SOFA.tf2a"><code>Astrometry.SOFA.tf2a</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tf2a(sign::Char, hour::Integer, minute::Integer, second::Real)</code></pre><p>Convert hours, minutes, seconds to radians.</p><p><strong>Input</strong></p><ul><li><code>sign</code>   – sign:  &#39;-&#39; = negative, otherwise positive</li><li><code>hour</code>   – hours</li><li><code>minute</code> – minutes</li><li><code>second</code> – seconds</li></ul><p><strong>Output</strong></p><ul><li><code>angle</code>  – angle in radians</li></ul><p><strong>Note</strong></p><ol><li><p>The result is computed even if any of the range checks fail.</p></li><li><p>Negative ihour, imin and/or sec produce a warning status, but the absolute value is used in the conversion.</p></li><li><p>If there are multiple errors, the status value reflects only the first, the smallest taking precedence.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L240-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.tf2d"><a class="docstring-binding" href="#Astrometry.SOFA.tf2d"><code>Astrometry.SOFA.tf2d</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tf2d(sign::Char, hour::Integer, minute::Integer, second::Real)</code></pre><p>Convert hours, minutes, seconds to days.</p><p><strong>Input</strong></p><ul><li><code>sign</code>   – sign:  &#39;-&#39; = negative, otherwise positive</li><li><code>hour</code>   – hours</li><li><code>minute</code> – minutes</li><li><code>second</code> – seconds</li></ul><p><strong>Output</strong></p><ul><li><code>day</code>    – interval in days</li></ul><p><strong>Note</strong></p><ol><li><p>The result is computed even if any of the range checks fail.</p></li><li><p>Negative ihour, imin and/or sec produce a warning status, but the absolute value is used in the conversion.</p></li><li><p>If there are multiple errors, the status value reflects only the first, the smallest taking precedence.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L275-L300">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rx"><a class="docstring-binding" href="#Astrometry.SOFA.rx"><code>Astrometry.SOFA.rx</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rx(ϕ::Real, r::AbstractMatrix{&lt;:Real})</code></pre><p>Rotate an r-matrix about the x-axis.</p><p><strong>Input</strong></p><ul><li><code>ϕ</code>     – angle (radians)</li><li><code>r</code>     – r-matrix</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – r-matrix, rotated</li></ul><p><strong>Note</strong></p><ol><li><p>Calling this function with positive ϕ incorporates in the supplied r-matrix r an additional rotation, about the x-axis, anticlockwise as seen looking towards the origin from positive x.</p></li><li><p>The additional rotation can be represented by this matrix:</p><pre><code class="nohighlight hljs">(  1        0            0      )
(                               )
(  0   + cos(ϕ)   + sin(ϕ)  )
(                               )
(  0   - sin(ϕ)   + cos(ϕ)  )</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L312-L340">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.ry"><a class="docstring-binding" href="#Astrometry.SOFA.ry"><code>Astrometry.SOFA.ry</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ry(θ::Real, r::AbstractMatrix{&lt;:Real})</code></pre><p>Rotate an r-matrix about the y-axis.</p><p><strong>Input</strong></p><ul><li><code>θ</code>     – angle (radians)</li><li><code>r</code>     – r-matrix</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – r-matrix, rotated</li></ul><p><strong>Note</strong></p><ol><li><p>Calling this function with positive theta incorporates in the supplied r-matrix r an additional rotation, about the y-axis, anticlockwise as seen looking towards the origin from positive y.</p></li><li><p>The additional rotation can be represented by this matrix:</p><pre><code class="nohighlight hljs">(  + cos(θ)     0      - sin(θ)  )
(                                        )
(       0           1           0        )
(                                        )
(  + sin(θ)     0      + cos(θ)  )</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L346-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rz"><a class="docstring-binding" href="#Astrometry.SOFA.rz"><code>Astrometry.SOFA.rz</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rz(ψ::Real, r::AbstractMatrix{&lt;:Real})</code></pre><p>Rotate an r-matrix about the z-axis.</p><p><strong>Input</strong></p><ul><li><code>ψ</code>     – angle (radians)</li><li><code>r</code>    – r-matrix</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – r-matrix, rotated</li></ul><p><strong>Note</strong></p><ol><li><p>Calling this function with positive ψ incorporates in the supplied r-matrix r an additional rotation, about the z-axis, anticlockwise as seen looking towards the origin from positive z.</p></li><li><p>The additional rotation can be represented by this matrix:</p><pre><code class="nohighlight hljs">(  + cos(ψ)   + sin(ψ)     0  )
(                              )
(  - sin(ψ)   + cos(ψ)     0  )
(                              )
(       0            0      1  )</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L379-L407">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rm2v"><a class="docstring-binding" href="#Astrometry.SOFA.rm2v"><code>Astrometry.SOFA.rm2v</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rm2v(r::AbstractMatrix{&lt;:Real})</code></pre><p>Express an r-matrix as an r-vector.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – rotation matrix</li></ul><p><strong>Output</strong></p><ul><li><code>w</code>     – rotation vector (Note 1)</li></ul><p><strong>Note</strong></p><ol><li><p>A rotation matrix describes a rotation through some angle about some arbitrary axis called the Euler axis.  The &quot;rotation vector&quot; returned by this function has the same direction as the Euler axis, and its magnitude is the angle in radians.  (The magnitude and direction can be separated by means of the function eraPn.)</p></li><li><p>If r is null, so is the result.  If r is not a rotation matrix the result is undefined; r must be proper (i.e. have a positive determinant) and real orthogonal (inverse = transpose).</p></li><li><p>The reference frame rotates clockwise as seen looking along the rotation vector from the origin.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L675-L702">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pap"><a class="docstring-binding" href="#Astrometry.SOFA.pap"><code>Astrometry.SOFA.pap</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pap(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>Position-angle from two p-vectors.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – direction of reference point</li><li><code>b</code>     – direction of point whose PA is required</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – position angle of b with respect to a (radians)</li></ul><p><strong>Note</strong></p><ol><li><p>The result is the position angle, in radians, of direction b with respect to direction a.  It is in the range -pi to +pi.  The sense is such that if b is a small distance &quot;north&quot; of a the position angle is approximately zero, and if b is a small distance &quot;east&quot; of a the position angle is approximately +pi/2.</p></li><li><p>The vectors a and b need not be of unit length.</p></li><li><p>Zero is returned if the two directions are the same or if either vector is null.</p></li><li><p>If vector a is at a pole, the result is ill-defined.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L745-L773">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pas"><a class="docstring-binding" href="#Astrometry.SOFA.pas"><code>Astrometry.SOFA.pas</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pas(λa::Real, ϕa::Real, λb::Real, ϕb::Real)</code></pre><p>Position-angle from spherical coordinates.</p><p><strong>Input</strong></p><ul><li><code>λa</code>    – longitude of point A (e.g. RA) in radians</li><li><code>ϕa</code>    – latitude of point A (e.g. Dec) in radians</li><li><code>λb</code>    – longitude of point B</li><li><code>ϕb</code>    – latitude of point B</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – position angle of B with respect to A</li></ul><p><strong>Note</strong></p><ol><li><p>The result is the bearing (position angle), in radians, of point B with respect to point A.  It is in the range -pi to +pi.  The sense is such that if B is a small distance &quot;east&quot; of point A, the bearing is approximately +pi/2.</p></li><li><p>Zero is returned if the two points are coincident.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L789-L813">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.sepp"><a class="docstring-binding" href="#Astrometry.SOFA.sepp"><code>Astrometry.SOFA.sepp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sepp(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>Angular separation between two p-vectors.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector (not necessarily unit length)</li><li><code>b</code>     – second p-vector (not necessarily unit length)</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – angular separation (radians, always positive)</li></ul><p><strong>Note</strong></p><ol><li><p>If either vector is null, a zero result is returned.</p></li><li><p>The angular separation is most simply formulated in terms of scalar product.  However, this gives poor accuracy for angles near zero and pi.  The present algorithm uses both cross product and dot product, to deliver full accuracy whatever the size of the angle.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L820-L842">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.seps"><a class="docstring-binding" href="#Astrometry.SOFA.seps"><code>Astrometry.SOFA.seps</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">seps(λa::Real, ϕa::Real, λb::Real, ϕb::Real)</code></pre><p>Angular separation between two sets of spherical coordinates.</p><p><strong>Input</strong></p><ul><li><code>λa</code>     – first longitude (radians)</li><li><code>ϕa</code>     – first latitude (radians)</li><li><code>λb</code>     – second longitude (radians)</li><li><code>ϕb</code>     – second latitude (radians)</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>      – angular separation (radians)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L850-L866">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.c2s"><a class="docstring-binding" href="#Astrometry.SOFA.c2s"><code>Astrometry.SOFA.c2s</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">c2s(pos::AbstractVector{&lt;:Real})</code></pre><p>P-vector to spherical coordinates.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li></ul><p><strong>Note</strong></p><ol><li><p>The vector p can have any magnitude; only its direction is used.</p></li><li><p>If p is null, zero θ and ϕ are returned.</p></li><li><p>At either pole, zero θ is returned.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L883-L904">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.p2s"><a class="docstring-binding" href="#Astrometry.SOFA.p2s"><code>Astrometry.SOFA.p2s</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">p2s(pos::AbstractVector{&lt;:Real})</code></pre><p>P-vector to spherical polar coordinates.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li><li><code>r</code>     – radial distance</li></ul><p><strong>Note</strong></p><ol><li><p>If P is null, zero θ, ϕ and r are returned.</p></li><li><p>At either pole, zero θ is returned.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L912-L932">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pv2s"><a class="docstring-binding" href="#Astrometry.SOFA.pv2s"><code>Astrometry.SOFA.pv2s</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pv2s(pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Convert position/velocity from Cartesian to spherical coordinates.</p><p><strong>Input</strong></p><ul><li><code>posvel</code> – position-velocity-vector</li></ul><p><strong>Output</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li><li><code>r</code>     – radial distance</li><li><code>dθ</code>    – rate of change of θ</li><li><code>dϕ</code>    – rate of change of ϕ</li><li><code>dr</code>    – rate of change of r</li></ul><p><strong>Note</strong></p><ol><li><p>If the position part of pv is null, theta, ϕ, td and pd are indeterminate.  This is handled by extrapolating the position through unit time by using the velocity part of pv.  This moves the origin without changing the direction of the velocity component. If the position and velocity components of pv are both null, zeroes are returned for all six results.</p></li><li><p>If the position is a pole, theta, td and pd are indeterminate.  In such cases zeroes are returned for all three.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L937-L966">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.s2c"><a class="docstring-binding" href="#Astrometry.SOFA.s2c"><code>Astrometry.SOFA.s2c</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2c(θ::Real, ϕ::Real)</code></pre><p>Convert spherical coordinates to Cartesian.</p><p><strong>Input</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>     – direction cosines</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L987-L1001">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.s2pv"><a class="docstring-binding" href="#Astrometry.SOFA.s2pv"><code>Astrometry.SOFA.s2pv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2pv(θ::Real, ϕ::Real, r::Real, dθ::Real, dϕ::Real,
     dr::Real)</code></pre><p>Convert position/velocity from spherical to Cartesian coordinates.</p><p><strong>Input</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li><li><code>r</code>     – radial distance</li><li><code>dθ</code>    – rate of change of θ</li><li><code>dϕ</code>    – rate of change of ϕ</li><li><code>dr</code>    – rate of change of r</li></ul><p><strong>Output</strong></p><ul><li><code>pv</code>    – pv-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1023-L1041">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pn"><a class="docstring-binding" href="#Astrometry.SOFA.pn"><code>Astrometry.SOFA.pn</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pn(p::AbstractVector{&lt;:Real})</code></pre><p>Convert a p-vector into modulus and unit vector.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – modulus</li><li><code>u</code>     – unit vector</li></ul><p><strong>Note</strong></p><ol><li>If p is null, the result is null.  Otherwise the result is a unit vector.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1098-L1116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvdpv"><a class="docstring-binding" href="#Astrometry.SOFA.pvdpv"><code>Astrometry.SOFA.pvdpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvdpv(a::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, b::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Inner (=scalar=dot) product of two pv-vectors.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first pv-vector</li><li><code>b</code>     – second pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>adb</code>   – a . b (see note)</li></ul><p><strong>Note</strong></p><ol><li>If the position and velocity components of the two pv-vectors are ( ap, av ) and ( bp, bv ), the result, a . b, is the pair of numbers ( ap . bp , ap . bv + av . bp ).  The two numbers are the dot-product of the two p-vectors and its derivative.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1157-L1177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvxpv"><a class="docstring-binding" href="#Astrometry.SOFA.pvxpv"><code>Astrometry.SOFA.pvxpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvxpv(a::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, b::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Outer (=vector=cross) product of two pv-vectors.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first pv-vector</li><li><code>b</code>     – second pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>axb</code>   – a x b</li></ul><p><strong>Note</strong></p><ol><li>If the position and velocity components of the two pv-vectors are ( ap, av ) and ( bp, bv ), the result, a x b, is the pair of vectors ( ap x bp, ap x bv + av x bp ).  The two vectors are the cross-product of the two p-vectors and its derivative.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1292-L1312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.cp"><a class="docstring-binding" href="#Astrometry.SOFA.cp"><code>Astrometry.SOFA.cp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cp(p::AbstractVector{&lt;:Real})</code></pre><p>Copy a p-vector.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector to be copied</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>     – copy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L415-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.cpv"><a class="docstring-binding" href="#Astrometry.SOFA.cpv"><code>Astrometry.SOFA.cpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cpv(pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Copy a position/velocity vector.</p><p><strong>Input</strong></p><ul><li><code>pv</code>     – pv-vector to be copied</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>      – copy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L430-L442">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.cr"><a class="docstring-binding" href="#Astrometry.SOFA.cr"><code>Astrometry.SOFA.cr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cr(r::AbstractMatrix{&lt;:Real})</code></pre><p>Copy an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix to be copied</li></ul><p><strong>Output</strong></p><ul><li><code>c</code>     – copy</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L445-L457">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.p2pv"><a class="docstring-binding" href="#Astrometry.SOFA.p2pv"><code>Astrometry.SOFA.p2pv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">p2pv(p::AbstractVector{&lt;:Real})</code></pre><p>Extend a p-vector to a pv-vector by appending a zero velocity.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>pv</code>    – pv-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L460-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pv2p"><a class="docstring-binding" href="#Astrometry.SOFA.pv2p"><code>Astrometry.SOFA.pv2p</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pv2p(pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Discard velocity component of a pv-vector.</p><p><strong>Input</strong></p><ul><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>p</code>     – p-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L478-L490">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.ir"><a class="docstring-binding" href="#Astrometry.SOFA.ir"><code>Astrometry.SOFA.ir</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ir()</code></pre><p>Initialize an r-matrix to the identity matrix.</p><p><strong>Output</strong></p><ul><li><code>r</code>     – r-matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L495-L503">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.zp"><a class="docstring-binding" href="#Astrometry.SOFA.zp"><code>Astrometry.SOFA.zp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zp()</code></pre><p>Zero a p-vector.</p><p><strong>Output</strong></p><ul><li><code>p</code>     – zero p-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L506-L513">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.zpv"><a class="docstring-binding" href="#Astrometry.SOFA.zpv"><code>Astrometry.SOFA.zpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zpv()</code></pre><p>Zero a pv-vector.</p><p><strong>Output</strong></p><ul><li><code>pv</code>    – zero pv-vector</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L516-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.zr"><a class="docstring-binding" href="#Astrometry.SOFA.zr"><code>Astrometry.SOFA.zr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">zr()</code></pre><p>Initialize an r-matrix to the null matrix.</p><p><strong>Output</strong></p><ul><li><code>r</code>     – r-matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L527-L534">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rxr"><a class="docstring-binding" href="#Astrometry.SOFA.rxr"><code>Astrometry.SOFA.rxr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rxr(a::AbstractMatrix{&lt;:Real}, b::AbstractMatrix{&lt;:Real})</code></pre><p>Multiply two r-matrices.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first r-matrix</li><li><code>b</code>     – second r-matrix</li></ul><p><strong>Output</strong></p><ul><li><code>atb</code>   – a * b</li></ul><p><strong>Note</strong></p><ol><li>It is permissible to re-use the same array for any of the arguments.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L539-L557">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.tr"><a class="docstring-binding" href="#Astrometry.SOFA.tr"><code>Astrometry.SOFA.tr</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">tr(r::AbstractMatrix{&lt;:Real})</code></pre><p>Transpose an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix</li></ul><p><strong>Output</strong></p><ul><li><code>rt</code>    – transpose</li></ul><p><strong>Note</strong></p><ol><li>It is permissible for r and rt to be the same array.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L560-L576">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rxp"><a class="docstring-binding" href="#Astrometry.SOFA.rxp"><code>Astrometry.SOFA.rxp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rxp(r::AbstractMatrix{&lt;:Real}, p::AbstractVector{&lt;:Real})</code></pre><p>Multiply a p-vector by an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix</li><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>rp</code>    – r * p</li></ul><p><strong>Note</strong></p><ol><li>It is permissible for p and rp to be the same array.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L581-L598">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.rxpv"><a class="docstring-binding" href="#Astrometry.SOFA.rxpv"><code>Astrometry.SOFA.rxpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rxpv(r::AbstractMatrix{&lt;:Real}, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Multiply a pv-vector by an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>rpv</code>   – r * pv</li></ul><p><strong>Note</strong></p><ol><li><p>The algorithm is for the simple case where the r-matrix r is not a function of time.  The case where r is a function of time leads to an additional velocity component equal to the product of the derivative of r and the position vector.</p></li><li><p>It is permissible for pv and rpv to be the same array.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L601-L623">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.trxp"><a class="docstring-binding" href="#Astrometry.SOFA.trxp"><code>Astrometry.SOFA.trxp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trxp(r::AbstractMatrix{&lt;:Real}, p::AbstractVector{&lt;:Real})</code></pre><p>Multiply a p-vector by the transpose of an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix</li><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>trp</code>   – r^T * p</li></ul><p><strong>Note</strong></p><ol><li>It is permissible for p and trp to be the same array.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L627-L644">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.trxpv"><a class="docstring-binding" href="#Astrometry.SOFA.trxpv"><code>Astrometry.SOFA.trxpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trxpv(r::AbstractMatrix{&lt;:Real}, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Multiply a pv-vector by the transpose of an r-matrix.</p><p><strong>Input</strong></p><ul><li><code>r</code>     – r-matrix</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>trpv</code>  – r^T * pv</li></ul><p><strong>Note</strong></p><ol><li><p>The algorithm is for the simple case where the r-matrix r is not a function of time.  The case where r is a function of time leads to an additional velocity component equal to the product of the derivative of the transpose of r and the position vector.</p></li><li><p>It is permissible for pv and rpv to be the same array.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L647-L669">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.s2p"><a class="docstring-binding" href="#Astrometry.SOFA.s2p"><code>Astrometry.SOFA.s2p</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2p(θ::Real, ϕ::Real, r::Real)</code></pre><p>Convert spherical polar coordinates to p-vector.</p><p><strong>Input</strong></p><ul><li><code>θ</code>     – longitude angle (radians)</li><li><code>ϕ</code>     – latitude angle (radians)</li><li><code>r</code>     – radial distance</li></ul><p><strong>Output</strong></p><ul><li><code>p</code>     – Cartesian coordinates</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1006-L1020">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pdp"><a class="docstring-binding" href="#Astrometry.SOFA.pdp"><code>Astrometry.SOFA.pdp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pdp(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>P-vector inner (=scalar=dot) product.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector</li><li><code>b</code>     – second p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – a . b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1051-L1064">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pm"><a class="docstring-binding" href="#Astrometry.SOFA.pm"><code>Astrometry.SOFA.pm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pm(p::AbstractVector{&lt;:Real}) = norm(p)</code></pre><p>Modulus of p-vector.</p><p><strong>Input</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – modulus</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1067-L1079">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pmp"><a class="docstring-binding" href="#Astrometry.SOFA.pmp"><code>Astrometry.SOFA.pmp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pmp(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>P-vector subtraction.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector</li><li><code>b</code>     – second p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>amb</code>   – a - b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1082-L1095">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.ppp"><a class="docstring-binding" href="#Astrometry.SOFA.ppp"><code>Astrometry.SOFA.ppp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ppp(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>P-vector addition.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector</li><li><code>b</code>     – second p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>apb</code>   – a + b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1124-L1137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.ppsp"><a class="docstring-binding" href="#Astrometry.SOFA.ppsp"><code>Astrometry.SOFA.ppsp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ppsp(a::AbstractVector{&lt;:Real}, s::Real, b::AbstractVector{&lt;:Real})</code></pre><p>P-vector plus scaled p-vector.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector</li><li><code>s</code>     – scalar (multiplier for b)</li><li><code>b</code>     – second p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>apsb</code>  – a + s*b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1140-L1154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvm"><a class="docstring-binding" href="#Astrometry.SOFA.pvm"><code>Astrometry.SOFA.pvm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvm(pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Modulus of pv-vector.</p><p><strong>Input</strong></p><ul><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>r</code>     – modulus of position component</li><li><code>s</code>     – modulus of velocity component</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1183-L1196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvmpv"><a class="docstring-binding" href="#Astrometry.SOFA.pvmpv"><code>Astrometry.SOFA.pvmpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvmpv(a::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, b::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Subtract one pv-vector from another.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first pv-vector</li><li><code>b</code>     – second pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>amb</code>   – a - b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1202-L1215">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvppv"><a class="docstring-binding" href="#Astrometry.SOFA.pvppv"><code>Astrometry.SOFA.pvppv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvppv(a::AbstractVector{&lt;:AbstractVector{&lt;:Real}}, b::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Add one pv-vector to another.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first pv-vector</li><li><code>b</code>     – second pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>apb</code>   – a + b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1221-L1234">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvu"><a class="docstring-binding" href="#Astrometry.SOFA.pvu"><code>Astrometry.SOFA.pvu</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvu(dt::Real, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Update a pv-vector.</p><p><strong>Input</strong></p><ul><li><code>dt</code>    – time interval</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>upv</code>   – p updated, v unchanged</li></ul><p><strong>Note</strong></p><ol><li><p>&quot;Update&quot; means &quot;refer the position component of the vector to a new date dt time units from the existing date&quot;.</p></li><li><p>The time units of dt must match those of the velocity.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1240-L1260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pvup"><a class="docstring-binding" href="#Astrometry.SOFA.pvup"><code>Astrometry.SOFA.pvup</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvup(dt::Real, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Update a pv-vector, discarding the velocity component.</p><p><strong>Input</strong></p><ul><li><code>dt</code>    – time interval</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>p</code>     – p-vector</li></ul><p><strong>Note</strong></p><ol><li><p>&quot;Update&quot; means &quot;refer the position component of the vector to a new date dt time units from the existing date&quot;.</p></li><li><p>The time units of dt must match those of the velocity.</p></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1266-L1286">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.pxp"><a class="docstring-binding" href="#Astrometry.SOFA.pxp"><code>Astrometry.SOFA.pxp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pxp(a::AbstractVector{&lt;:Real}, b::AbstractVector{&lt;:Real})</code></pre><p>P-vector outer (=vector=cross) product.</p><p><strong>Input</strong></p><ul><li><code>a</code>     – first p-vector</li><li><code>b</code>     – second p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>axb</code>   – a x b</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1318-L1331">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.s2xpv"><a class="docstring-binding" href="#Astrometry.SOFA.s2xpv"><code>Astrometry.SOFA.s2xpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">s2xpv(s1::Real, s2::Real, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Multiply a pv-vector by two scalars.</p><p><strong>Input</strong></p><ul><li><code>s1</code>    – scalar to multiply position component by</li><li><code>s2</code>    – scalar to multiply velocity component by</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>spv</code>   – pv-vector: p scaled by s1, v scaled by s2</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1337-L1351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.sxp"><a class="docstring-binding" href="#Astrometry.SOFA.sxp"><code>Astrometry.SOFA.sxp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sxp(s::Real, p::AbstractVector{&lt;:Real})</code></pre><p>Multiply a p-vector by a scalar.</p><p><strong>Input</strong></p><ul><li><code>s</code>     – scalar</li><li><code>p</code>     – p-vector</li></ul><p><strong>Output</strong></p><ul><li><code>sp</code>    – s * p</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1357-L1370">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Astrometry.SOFA.sxpv"><a class="docstring-binding" href="#Astrometry.SOFA.sxpv"><code>Astrometry.SOFA.sxpv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">sxpv(s::Real, pv::AbstractVector{&lt;:AbstractVector{&lt;:Real}})</code></pre><p>Multiply a pv-vector by a scalar.</p><p><strong>Input</strong></p><ul><li><code>s</code>     – scalar</li><li><code>pv</code>    – pv-vector</li></ul><p><strong>Output</strong></p><ul><li><code>spv</code>   – s * pv</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaAstro/Astrometry.jl/blob/714bc58d74806b2aeeb7aecb6d951b73c267b2b9/src/SOFA/vectorops.jl#L1373-L1386">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../timescales/">« Timescales</a><a class="docs-footer-nextpage" href="../../api/">API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Sunday 21 December 2025 23:41">Sunday 21 December 2025</span>. Using Julia version 1.12.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
